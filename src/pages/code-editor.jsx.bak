import React, { useState, useEffect, useRef } from "react";
import { useParams, useNavigate } from "react-router-dom";
import { supabase } from "../supabaseClient";
import MonacoEditor from "@monaco-editor/react";
import * as monaco from "monaco-editor";
import { loader } from "@monaco-editor/react";
import keywordSuggestions from "../../data/KeywordSuggestions";

// --- Language Icons ---
const LanguageIcons = {
  python: (
    <svg viewBox="0 0 128 128" className="w-5 h-5 mr-2">
      <linearGradient id="python-original-a" gradientUnits="userSpaceOnUse" x1="70.252" y1="1237.476" x2="170.659" y2="1151.089" gradientTransform="matrix(.563 0 0 -.568 -29.215 707.817)"><stop offset="0" stopColor="#5A9FD4"></stop><stop offset="1" stopColor="#306998"></stop></linearGradient>
      <linearGradient id="python-original-b" gradientUnits="userSpaceOnUse" x1="209.474" y1="1098.811" x2="173.62" y2="1149.537" gradientTransform="matrix(.563 0 0 -.568 -29.215 707.817)"><stop offset="0" stopColor="#FFD43B"></stop><stop offset="1" stopColor="#FFE873"></stop></linearGradient>
      <path fill="url(#python-original-a)" d="M63.391 1.988c-4.222.02-8.252.379-11.8 1.007-10.45 1.846-12.346 5.71-12.346 12.837v9.411h24.693v3.137H29.977c-7.176 0-13.46 4.313-15.426 12.521-2.268 9.405-2.368 15.275 0 25.096 1.755 7.311 5.947 12.519 13.124 12.519h8.491V67.234c0-8.151 7.051-15.34 15.426-15.34h24.665c6.866 0 12.346-5.654 12.346-12.548V15.833c0-6.693-5.646-11.72-12.346-12.837-4.244-.706-8.645-1.027-12.866-1.008zM50.037 9.557c2.55 0 4.634 2.117 4.634 4.721 0 2.593-2.083 4.69-4.634 4.69-2.56 0-4.633-2.097-4.633-4.69-.001-2.604 2.073-4.721 4.633-4.721z" transform="translate(0 10.26)"></path><path fill="url(#python-original-b)" d="M91.682 28.38v10.966c0 8.5-7.208 15.655-15.426 15.655H51.591c-6.756 0-12.346 5.783-12.346 12.549v23.515c0 6.691 5.818 10.628 12.346 12.547 7.816 2.297 15.312 2.713 24.665 0 6.216-1.801 12.346-5.423 12.346-12.547v-9.412H63.938v-3.138h37.012c7.176 0 9.852-5.005 12.348-12.519 2.578-7.735 2.467-15.174 0-25.096-1.774-7.145-5.161-12.521-12.348-12.521h-9.268zM77.809 87.927c2.561 0 4.634 2.097 4.634 4.692 0 2.602-2.074 4.719-4.634 4.719-2.55 0-4.633-2.117-4.633-4.719 0-2.595 2.083-4.692 4.633-4.692z" transform="translate(0 10.26)"></path><path opacity=".444" fill="#fff" fillRule="nonzero" d="M97.309 119.597c0 3.543-14.816 6.416-33.091 6.416-18.276 0-33.092-2.873-33.092-6.416 0-3.544 14.815-6.417 33.092-6.417 18.275 0 33.091 2.872 33.091 6.417z"></path>
    </svg>
  ),
  javascript: (
    <svg viewBox="0 0 128 128" className="w-5 h-5 mr-2">
      <path fill="#F0DB4F" d="M1.408 1.408h125.184v125.185H1.408z"></path><path fill="#323330" d="M116.347 96.736c-.917-5.711-4.641-10.508-15.672-14.981-3.832-1.761-8.104-3.022-9.377-5.926-.452-1.69-.512-2.642-.226-3.665.821-3.32 4.784-4.355 7.925-3.403 2.023.678 3.938 2.237 5.093 4.724 5.402-3.498 5.391-3.475 9.163-5.879-1.381-2.141-2.118-3.129-3.022-4.045-3.249-3.629-7.676-5.498-14.756-5.355l-3.688.477c-3.534.893-6.902 2.748-8.877 5.235-5.926 6.724-4.236 18.492 2.975 23.335 7.104 5.332 17.54 6.545 18.873 11.531 1.297 6.104-4.486 8.08-10.234 7.378-4.236-.881-6.592-3.034-9.139-6.949-4.688 2.713-4.688 2.713-9.508 5.485 1.143 2.499 2.344 3.63 4.26 5.795 9.068 9.198 31.76 8.746 35.83-5.176.165-.478 1.261-3.666.38-8.581zM69.462 58.943H57.753l-.048 30.272c0 6.438.333 12.34-.714 14.149-1.713 3.558-6.152 3.117-8.175 2.427-2.059-1.012-3.106-2.451-4.319-4.485-.333-.584-.583-1.036-.667-1.071l-9.52 5.83c1.583 3.249 3.915 6.069 6.902 7.901 4.462 2.678 10.459 3.499 16.731 2.059 4.082-1.189 7.604-3.652 9.448-7.401 2.666-4.915 2.094-10.864 2.07-17.444.06-10.735.001-21.468.001-32.237z"></path>
    </svg>
  ),
  cpp: (
    <svg viewBox="0 0 128 128" className="w-5 h-5 mr-2">
      <path fill="#D26383" d="M115.4 30.7L67.1 2.9c-.8-.5-1.9-.7-3.1-.7-1.2 0-2.3.3-3.1.7l-48 27.9c-1.7 1-2.9 3.5-2.9 5.4v55.7c0 1.1.2 2.4 1 3.5l106.8-62c-.6-1.2-1.5-2.1-2.4-2.7z"></path><path fill="#9C033A" d="M10.7 95.3c.5.8 1.2 1.5 1.9 1.9l48.2 27.9c.8.5 1.9.7 3.1.7 1.2 0 2.3-.3 3.1-.7l48-27.9c1.7-1 2.9-3.5 2.9-5.4V36.1c0-.9-.1-1.9-.6-2.8l-106.6 62z"></path><path fill="#fff" d="M85.3 76.1C81.1 83.5 73.1 88.5 64 88.5c-13.5 0-24.5-11-24.5-24.5s11-24.5 24.5-24.5c9.1 0 17.1 5 21.3 12.5l13-7.5c-6.8-11.9-19.6-20-34.3-20-21.8 0-39.5 17.7-39.5 39.5s17.7 39.5 39.5 39.5c14.6 0 27.4-8 34.2-19.8l-12.9-7.6z"></path><path d="M82.1 61.8h5.2v-5.3h4.4v5.3H97v4.4h-5.3v5.2h-4.4v-5.2h-5.2v-4.4zm18.5 0h5.2v-5.3h4.4v5.3h5.3v4.4h-5.3v5.2h-4.4v-5.2h-5.2v-4.4z" fill="#fff"></path>
    </svg>
  ),
  java: (
    <svg viewBox="0 0 128 128" className="w-5 h-5 mr-2">
      <path fill="#0074BD" d="M47.617 98.12s-4.767 2.774 3.397 3.71c9.892 1.13 14.947.968 25.845-1.092 0 0 2.871 1.795 6.873 3.351-24.439 10.47-55.308-.607-36.115-5.969zm-2.988-13.665s-5.348 3.959 2.823 4.805c10.567 1.091 18.91 1.18 33.354-1.6 0 0 1.993 2.025 5.132 3.131-29.542 8.64-62.446.68-41.309-6.336z"></path><path fill="#EA2D2E" d="M69.802 61.271c6.025 6.935-1.58 13.17-1.58 13.17s15.289-7.891 8.269-17.777c-6.559-9.215-11.587-13.792 15.635-29.58 0 .001-42.731 10.67-22.324 34.187z"></path><path fill="#0074BD" d="M102.123 108.229s3.529 2.91-3.888 5.159c-14.102 4.272-58.706 5.56-71.094.171-4.451-1.938 3.899-4.625 6.526-5.192 2.739-.593 4.303-.485 4.303-.485-4.953-3.487-32.013 6.85-13.743 9.815 49.821 8.076 90.817-3.637 77.896-9.468zM49.912 70.294s-22.686 5.389-8.033 7.348c6.188.828 18.518.638 30.011-.326 9.39-.789 18.813-2.474 18.813-2.474s-3.308 1.419-5.704 3.053c-23.042 6.061-67.544 3.238-54.731-2.958 10.832-5.239 19.644-4.643 19.644-4.643zm40.697 22.747c23.421-12.167 12.591-23.86 5.032-22.285-1.848.385-2.677.72-2.677.72s.688-1.079 2-1.543c14.953-5.255 26.451 15.503-4.823 23.725 0-.002.359-.327.468-.617z"></path><path fill="#EA2D2E" d="M76.491 1.587S89.459 14.563 64.188 34.51c-20.266 16.006-4.621 25.13-.007 35.559-11.831-10.673-20.509-20.07-14.688-28.815C58.041 28.42 81.722 22.195 76.491 1.587z"></path><path fill="#0074BD" d="M52.214 126.021c22.476 1.437 57-.8 57.817-11.436 0 0-1.571 4.032-18.577 7.231-19.186 3.612-42.854 3.191-56.887.874 0 .001 2.875 2.381 17.647 3.331z"></path>
    </svg>
  )
};

// --- Config ---
const GEMINI_API_KEY = import.meta.env.VITE_GEMINI_KEY || "";

// --- Mood GIFs ---
const moods = {
  neutral: "https://media.giphy.com/media/xT9IgzoKnwFNmISR8I/giphy.gif",
  running: "https://i.giphy.com/media/v1.Y2lkPTc5MGI3NjExaXNqZ3Y0Z2RkZ2w5a2ZqY2ZpZ3J5b3R4c3B6c3h6eXJtY3h5eHh5eCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/l4KhVp1b2e4M2o2mQ/giphy.gif",
  success: "https://i.giphy.com/media/111ebonMs90YLu/giphy.gif",
  fail: "https://i.giphy.com/media/26n6WywJyh39n1pBu/giphy.gif"
};

export default function CodeEditor() {
  const { problemId } = useParams(); // Get problemId from URL
  const navigate = useNavigate();
  const editorRef = useRef(null);

  const [allProblems, setAllProblems] = useState([]);
  const [currentProblem, setCurrentProblem] = useState(null);
  const [language, setLanguage] = useState("python");
  const [code, setCode] = useState("");
  const [output, setOutput] = useState("Select a problem to start coding.");
  const [mood, setMood] = useState(moods.neutral);
  const [isRunning, setIsRunning] = useState(false);
  const [user, setUser] = useState(null);
  const [userData, setUserData] = useState(null);
  const [isProblemSolved, setIsProblemSolved] = useState(false);
  const [suggestions, setSuggestions] = useState([]);

  // --- Fetch User, All Problems, and Specific Problem Data ---
  useEffect(() => {
    // 1. Check for authenticated user
    const fetchUser = async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (user) {
        setUser(user);
        // Fetch additional user data from users table
        const { data, error } = await supabase
          .from("users")
          .select("*")
          .eq("id", user.id)
          .single();
        
        if (error) {
          console.error("Error fetching user data:", error);
        } else {
          setUserData(data);
        }
      } else {
        navigate('/login');
      }
    };
    fetchUser();

    // 2. Fetch all problems for the dropdown selector
    const fetchAllProblems = async () => {
        const { data, error } = await supabase.from("problems").select("id, title");
        if (error) {
            console.error("Error fetching problem list:", error);
        } else {
            setAllProblems(data);
        }
    };
    fetchAllProblems();

  }, [navigate]);

  // --- Fetch Problem and Last Submission Together ---
  useEffect(() => {
    if (!user || !problemId) return;
    let isMounted = true;
    const fetchProblemAndSubmission = async () => {
      setCurrentProblem(null);
      setOutput("Loading problem...");
      // Fetch problem
      const { data: problemData, error: problemError } = await supabase
        .from("problems")
        .select("*")
        .eq("id", problemId)
        .single();
      if (problemError) {
        if (isMounted) {
          setOutput(`Error loading problem: ${problemError.message}`);
          setCurrentProblem(null);
        }
        return;
      }
      // Fetch last submission
      const { data: submissionData, error: submissionError } = await supabase
        .from("submissions")
        .select("code, language, output")
        .eq("user_id", user.id)
        .eq("problem_id", problemId)
        .order("created_at", { ascending: false })
        .limit(1)
        .single();
      if (isMounted) {
        setCurrentProblem(problemData);
        if (submissionData) {
          setCode(submissionData.code || "");
          setLanguage(submissionData.language || "python");
          setOutput(submissionData.output || "Loaded your last submission.");
          setIsProblemSolved(true);
        } else {
          const defaultBoilerplate = problemData.boilerplate?.[language] || ``;
          setCode(defaultBoilerplate);
          setOutput("Ready to code.");
          setIsProblemSolved(false);
        }
      }
    };
    fetchProblemAndSubmission();
    return () => { isMounted = false; };
  }, [user, problemId, language]);


  const runCode = async () => {
    if (!currentProblem || !code.trim()) {
      setOutput("âš ï¸ Please select a problem and write some code.");
      return;
    }
    
    const apiKey = GEMINI_API_KEY; 
    if (!apiKey) {
      setOutput("âŒ Gemini API key missing. Please set VITE_GEMINI_KEY in your environment variables.");
      return;
    }

    setIsRunning(true);
    setMood(moods.running);
    setOutput("â³ Evaluating your code...");

    const testCasesText = currentProblem.test_cases
      ?.map((tc, i) => `Test Case ${i + 1}: Input: ${JSON.stringify(tc.input)}, Expected: ${tc.output}`)
      .join("\n");

    const prompt = `
      You are a compiler. Strictly give only the output for the problem provided.
      Evaluate the following ${language} code for the problem "${currentProblem.title}".

      Problem:
      ${currentProblem.description}

      Code:
      \`\`\`${language}
      ${code}
      \`\`\`

      Test cases:
      ${testCasesText}

      Return results in this format:
      - Give actual output for each test case.
      - Give time complexity and space complexity.
      - "âœ… Success! All test cases passed." if correct.
      - "âŒ Failed Test Case X: ..." if incorrect.
      - "ðŸ’¥ Compilation Error: ..." if compile/runtime error.
    `;

    try {
      const res = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            contents: [{ parts: [{ text: prompt }] }]
          })
        }
      );

      const data = await res.json();
      if (!res.ok) throw new Error(data.error?.message || "Unknown error");

      const aiOutput = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
      if (!aiOutput) throw new Error("No response from AI.");

      if (aiOutput.includes("âœ…")) {
        setMood(moods.success);
        // Award XP when all test cases pass
        if (user) {
          await awardXP(currentProblem.difficulty || "Easy");
        }
      } else {
        setMood(moods.fail);
      }

      setOutput(aiOutput);
    } catch (err) {
      setMood(moods.fail);
      setOutput(`ðŸ’¥ API Error: ${err.message}`);
    } finally {
      setIsRunning(false);
    }
  };
  
  // --- Award XP Function ---
  const awardXP = async (difficulty) => {
    try {
      // Determine XP amount based on difficulty
      let xpAmount = 10; // Default/Easy
      
      if (difficulty === 'Medium') {
        xpAmount = 20;
      } else if (difficulty === 'Hard') {
        xpAmount = 30;
      } else if (difficulty === 'Expert') {
        xpAmount = 50;
      }
      
      // Fetch current user data
      const { data: userData, error: userError } = await supabase
        .from('users')
        .select('xp, level')
        .eq('id', user.id)
        .single();
        
      if (userError) throw userError;
      
      // Calculate new values
      const newXP = (userData.xp || 0) + xpAmount;
      const newLevel = Math.floor(newXP / 100) + 1; // Level up every 100 XP
      const didLevelUp = newLevel > (userData.level || 1);
      
      // Update user data in Supabase
      const { error } = await supabase
        .from('users')
        .update({
          xp: newXP,
          level: newLevel
        })
        .eq('id', user.id);
        
      if (error) throw error;
      
      // Show success message with XP gained
      setOutput(prev => `${prev}\n\nðŸŽ‰ You earned ${xpAmount} XP for solving this problem!${didLevelUp ? `\nðŸ† Congratulations! You've reached level ${newLevel}!` : ''}`);
      
      // Update local user data
      setUserData(prev => ({
        ...prev,
        xp: newXP,
        level: newLevel
      }));
      
    } catch (err) {
      console.error('Error awarding XP:', err);
    }
  };

  const submitCode = async () => {
    if (!user) {
      alert("âš ï¸ User not logged in.");
      return;
    }
    if (!currentProblem) {
      alert("âš ï¸ No problem selected.");
      return;
    }
    if (!code.trim()) {
      alert("âš ï¸ Write some code before submitting.");
      return;
    }

    const { error } = await supabase.from("submissions").insert([
      {
        user_id: user.id,
        problem_id: currentProblem.id,
        code,
        language,
        output, // Save the last run output with the submission
        test_cases: currentProblem.test_cases
      }
    ]);

    if (error) {
      alert("âŒ Error submitting: " + error.message);
    } else {
      alert("âœ… Submission saved successfully!");
    }
  };

  const handleProblemSelect = (selectedProblemId) => {
    if (selectedProblemId) {
        navigate(`/editor/${selectedProblemId}`);
    }
  };
  
  // Function to handle editor mounting
  const handleEditorDidMount = (editor, monaco) => {
    editorRef.current = editor;
    
    // Set up auto-completion provider for the current language
    setupAutoCompletion(monaco, language);
    
    // Update auto-completion when language changes
    editor.onDidChangeModelLanguage(() => {
      setupAutoCompletion(monaco, language);
    });
  };
  
  // Function to set up auto-completion for a specific language
  const setupAutoCompletion = (monaco, language) => {
    // Register completion provider for the language
    monaco.languages.registerCompletionItemProvider(language, {
      provideCompletionItems: (model, position) => {
        const textUntilPosition = model.getValueInRange({
          startLineNumber: position.lineNumber,
          startColumn: 1,
          endLineNumber: position.lineNumber,
          endColumn: position.column,
        });
        
        // Get current word being typed
        const word = textUntilPosition.replace(/.*[\s\(\{\[\=\+\-\*\/\,\;\:\<\>\!\&\|\^\%\~\?]([^\s\(\{\[\=\+\-\*\/\,\;\:\<\>\!\&\|\^\%\~\?]*)$/, '$1');
        
        // Only show suggestions if the word is at least 1 character long
        if (word.length < 1) return { suggestions: [] };
        
        // Generate suggestions based on language
        let completions = [];
        
        // Get code context (surrounding lines)
        const lineCount = model.getLineCount();
        const startLine = Math.max(1, position.lineNumber - 15); // Increased context range
        const endLine = Math.min(lineCount, position.lineNumber + 15);
        const codeContext = model.getValueInRange({
          startLineNumber: startLine,
          startColumn: 1,
          endLineNumber: endLine,
          endColumn: model.getLineMaxColumn(endLine),
        });
        
        // Extract variable names and function names from context
        const contextWords = extractContextWords(codeContext, language, monaco);
        
        // Get language-specific keywords from imported keywordSuggestions
        const languageKeywords = getFormattedKeywordSuggestions(language, monaco);
        
        // Get snippets for the current language
        const snippets = getLanguageSnippets(language, monaco);
        
        // Combine context words, language keywords, and snippets
        completions = [...contextWords, ...languageKeywords, ...snippets]
          .filter(item => item.label.toLowerCase().includes(word.toLowerCase())) // Case-insensitive filtering
          .sort((a, b) => {
            // Prioritize exact matches
            const aStartsWithWord = a.label.toLowerCase().startsWith(word.toLowerCase());
            const bStartsWithWord = b.label.toLowerCase().startsWith(word.toLowerCase());
            
            if (aStartsWithWord && !bStartsWithWord) return -1;
            if (!aStartsWithWord && bStartsWithWord) return 1;
            
            // Then prioritize by kind (snippets first, then keywords, then variables)
            const aKindValue = getKindPriority(a.kind);
            const bKindValue = getKindPriority(b.kind);
            if (aKindValue !== bKindValue) return aKindValue - bKindValue;
            
            // Finally sort alphabetically
            return a.label.localeCompare(b.label);
          });
        
        return {
          suggestions: completions,
        };
      },
      triggerCharacters: ['.', '"', "'", '(', '{', '[', ',', '$', '#', '@', ':', '_'],
    });
  };
  
  // Helper function to prioritize completion items by kind
  const getKindPriority = (kind) => {
    const monaco = window.monaco;
    if (!monaco) return 999;
    
    const priorities = {
      [monaco.languages.CompletionItemKind.Snippet]: 1,
      [monaco.languages.CompletionItemKind.Keyword]: 2,
      [monaco.languages.CompletionItemKind.Function]: 3,
      [monaco.languages.CompletionItemKind.Method]: 4,
      [monaco.languages.CompletionItemKind.Class]: 5,
      [monaco.languages.CompletionItemKind.Variable]: 6,
      [monaco.languages.CompletionItemKind.Property]: 7,
    };
    
    return priorities[kind] || 999;
  };
  
  // Function to extract context words from code
  const extractContextWords = (codeContext, language, monaco) => {
    let words = [];
    let regex;
    
    // Different regex patterns for different languages
    switch (language) {
      case 'python':
        // Match variable assignments, function definitions, class definitions, and imports
        regex = /\b(def|class)\s+([a-zA-Z_][a-zA-Z0-9_]*)\b|\b(from|import)\s+([a-zA-Z_][a-zA-Z0-9_.]*)\b|\b([a-zA-Z_][a-zA-Z0-9_]*)\s*[=\(]/g;
        break;
      case 'javascript':
        // Match variable declarations, function declarations, class declarations, and method calls
        regex = /\b(var|let|const|function|class)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\b|\b([a-zA-Z_$][a-zA-Z0-9_$]*)\s*[=\(\.]|\.([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\(/g;
        break;
      case 'java':
        // Match class declarations, method declarations, variable declarations
        regex = /\b(class|interface|enum)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\b|\b(public|private|protected|static|final)\s+([a-zA-Z_$][a-zA-Z0-9_$<>\[\].]*)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*[\(=;]|\b([a-zA-Z_$][a-zA-Z0-9_$]*)\s*[=\(\.]|\.([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\(/g;
        break;
      case 'cpp':
        // Match class declarations, function declarations, variable declarations
        regex = /\b(class|struct|enum)\s+([a-zA-Z_][a-zA-Z0-9_]*)\b|\b([a-zA-Z_][a-zA-Z0-9_:<>]*)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*[\(=;]|\b([a-zA-Z_][a-zA-Z0-9_]*)\s*[=\(\.]|\.([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
        break;
      default:
        regex = /\b([a-zA-Z_$][a-zA-Z0-9_$]*)\b/g;
    }
    
    let match;
    const foundWords = new Set();
    
    while ((match = regex.exec(codeContext)) !== null) {
      // Get the matched word (could be in different capture groups)
      const word = match.slice(1).find(w => w !== undefined);
      
      if (word && !foundWords.has(word) && !isCommonKeyword(word, language)) {
        foundWords.add(word);
        
        // Determine the kind based on context
        let kind = monaco.languages.CompletionItemKind.Variable;
        let detail = 'Variable from context';
        
        if (match[0].includes('function') || match[0].includes('def ')) {
          kind = monaco.languages.CompletionItemKind.Function;
          detail = 'Function from context';
        } else if (match[0].includes('class ')) {
          kind = monaco.languages.CompletionItemKind.Class;
          detail = 'Class from context';
        } else if (match[0].includes('.')) {
          kind = monaco.languages.CompletionItemKind.Method;
          detail = 'Method from context';
        }
        
        words.push({
          label: word,
          kind: kind,
          detail: detail,
          insertText: word,
        });
      }
    }
    
    return words;
  };
  
  // Helper function to check if a word is a common keyword that should be excluded from context suggestions
  const isCommonKeyword = (word, language) => {
    const commonKeywords = {
      python: ['if', 'else', 'elif', 'for', 'while', 'def', 'class', 'return', 'import', 'from', 'as', 'try', 'except', 'finally', 'with', 'True', 'False', 'None'],
      javascript: ['if', 'else', 'for', 'while', 'function', 'return', 'var', 'let', 'const', 'class', 'new', 'this', 'true', 'false', 'null', 'undefined'],
      java: ['if', 'else', 'for', 'while', 'class', 'return', 'public', 'private', 'protected', 'static', 'void', 'int', 'boolean', 'String', 'true', 'false', 'null'],
      cpp: ['if', 'else', 'for', 'while', 'class', 'return', 'int', 'char', 'bool', 'float', 'double', 'void', 'struct', 'enum', 'public', 'private', 'protected', 'true', 'false', 'nullptr'],
    };
    
    return commonKeywords[language]?.includes(word) || false;
  };
  
  // Function to format keyword suggestions from the imported keywordSuggestions
  const getFormattedKeywordSuggestions = (language, monaco) => {
    // Get the language-specific keywords from the imported keywordSuggestions
    const keywords = keywordSuggestions[language] || [];
    
    if (!keywords || keywords.length === 0) {
      return [];
    }
    
    // Map the keywords to the format expected by Monaco
    return keywords.map(keyword => {
      // Determine if this is a function-like keyword
      const isFunctionLike = keyword.includes('(') || 
                            (/\.(\w+)$/.test(keyword) && !keyword.includes(' '));
      
      // Determine the kind based on the keyword
      let kind = monaco.languages.CompletionItemKind.Keyword;
      let insertText = keyword;
      let detail = 'Keyword';
      let documentation = '';
      
      if (isFunctionLike) {
        kind = monaco.languages.CompletionItemKind.Function;
        detail = 'Function';
        
        // For method calls, add parentheses if not already present
        if (keyword.includes('.') && !keyword.includes('(')) {
          insertText = `${keyword}($0)`;
        }
      } else if (keyword.startsWith('class') || keyword.startsWith('interface')) {
        kind = monaco.languages.CompletionItemKind.Class;
        detail = keyword.startsWith('class') ? 'Class' : 'Interface';
      } else if (keyword.startsWith('@')) {
        kind = monaco.languages.CompletionItemKind.Snippet;
        detail = 'Decorator';
      }
      
      return {
        label: keyword,
        kind: kind,
        insertText: insertText,
        detail: detail,
        documentation: documentation,
      };
    });
  };
  
  // Function to get language-specific code snippets
  const getLanguageSnippets = (language, monaco) => {
    switch (language) {
      case 'python':
        return [
          {
            label: 'def function',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'def ${1:function_name}(${2:parameters}):\n\t${0:pass}',
            detail: 'Function definition',
            documentation: 'Define a new function',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'class definition',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'class ${1:ClassName}:\n\tdef __init__(self, ${2:parameters}):\n\t\t${0:pass}',
            detail: 'Class definition',
            documentation: 'Define a new class',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'for loop',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'for ${1:item} in ${2:iterable}:\n\t${0:pass}',
            detail: 'For loop',
            documentation: 'Create a for loop',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'if statement',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'if ${1:condition}:\n\t${0:pass}',
            detail: 'If statement',
            documentation: 'Create an if statement',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'if-else statement',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'if ${1:condition}:\n\t${2:pass}\nelse:\n\t${0:pass}',
            detail: 'If-else statement',
            documentation: 'Create an if-else statement',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'try-except',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'try:\n\t${1:pass}\nexcept ${2:Exception} as ${3:e}:\n\t${0:pass}',
            detail: 'Try-except block',
            documentation: 'Create a try-except block',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
        ];
      case 'javascript':
        return [
          {
            label: 'function declaration',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'function ${1:name}(${2:parameters}) {\n\t${0}\n}',
            detail: 'Function declaration',
            documentation: 'Define a new function',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'arrow function',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: '(${1:parameters}) => {\n\t${0}\n}',
            detail: 'Arrow function',
            documentation: 'Define an arrow function',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'class declaration',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'class ${1:Name} {\n\tconstructor(${2:parameters}) {\n\t\t${0}\n\t}\n}',
            detail: 'Class declaration',
            documentation: 'Define a new class',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'for loop',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'for (let ${1:i} = 0; ${1:i} < ${2:array}.length; ${1:i}++) {\n\t${0}\n}',
            detail: 'For loop',
            documentation: 'Create a for loop',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'forEach loop',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: '${1:array}.forEach((${2:item}) => {\n\t${0}\n});',
            detail: 'forEach loop',
            documentation: 'Create a forEach loop',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'if statement',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'if (${1:condition}) {\n\t${0}\n}',
            detail: 'If statement',
            documentation: 'Create an if statement',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'if-else statement',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'if (${1:condition}) {\n\t${2}\n} else {\n\t${0}\n}',
            detail: 'If-else statement',
            documentation: 'Create an if-else statement',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'try-catch',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'try {\n\t${1}\n} catch (${2:error}) {\n\t${0}\n}',
            detail: 'Try-catch block',
            documentation: 'Create a try-catch block',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
        ];
      case 'java':
        return [
          {
            label: 'public class',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'public class ${1:ClassName} {\n\t${0}\n}',
            detail: 'Public class',
            documentation: 'Define a new public class',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'public method',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'public ${1:void} ${2:methodName}(${3:parameters}) {\n\t${0}\n}',
            detail: 'Public method',
            documentation: 'Define a new public method',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'main method',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'public static void main(String[] args) {\n\t${0}\n}',
            detail: 'Main method',
            documentation: 'Define the main method',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'for loop',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'for (int ${1:i} = 0; ${1:i} < ${2:array}.length; ${1:i}++) {\n\t${0}\n}',
            detail: 'For loop',
            documentation: 'Create a for loop',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'enhanced for loop',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'for (${1:Type} ${2:item} : ${3:collection}) {\n\t${0}\n}',
            detail: 'Enhanced for loop',
            documentation: 'Create an enhanced for loop',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'if statement',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'if (${1:condition}) {\n\t${0}\n}',
            detail: 'If statement',
            documentation: 'Create an if statement',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'if-else statement',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'if (${1:condition}) {\n\t${2}\n} else {\n\t${0}\n}',
            detail: 'If-else statement',
            documentation: 'Create an if-else statement',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'try-catch',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'try {\n\t${1}\n} catch (${2:Exception} ${3:e}) {\n\t${0}\n}',
            detail: 'Try-catch block',
            documentation: 'Create a try-catch block',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
        ];
      case 'cpp':
        return [
          {
            label: 'class definition',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'class ${1:ClassName} {\npublic:\n\t${1:ClassName}() {\n\t\t${0}\n\t}\n};',
            detail: 'Class definition',
            documentation: 'Define a new class',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'function definition',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: '${1:void} ${2:functionName}(${3:parameters}) {\n\t${0}\n}',
            detail: 'Function definition',
            documentation: 'Define a new function',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'main function',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'int main(int argc, char* argv[]) {\n\t${0}\n\treturn 0;\n}',
            detail: 'Main function',
            documentation: 'Define the main function',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'for loop',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'for (int ${1:i} = 0; ${1:i} < ${2:size}; ${1:i}++) {\n\t${0}\n}',
            detail: 'For loop',
            documentation: 'Create a for loop',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'if statement',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'if (${1:condition}) {\n\t${0}\n}',
            detail: 'If statement',
            documentation: 'Create an if statement',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'if-else statement',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'if (${1:condition}) {\n\t${2}\n} else {\n\t${0}\n}',
            detail: 'If-else statement',
            documentation: 'Create an if-else statement',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'try-catch',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: 'try {\n\t${1}\n} catch (${2:std::exception& e}) {\n\t${0}\n}',
            detail: 'Try-catch block',
            documentation: 'Create a try-catch block',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
          {
            label: 'include',
            kind: monaco.languages.CompletionItemKind.Snippet,
            insertText: '#include <${1:iostream}>\n${0}',
            detail: 'Include directive',
            documentation: 'Add an include directive',
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          },
        ];
      default:
        return [];
    }
  };
  
  // Function to get language-specific keywords
  const getLanguageKeywords = (language) => {
    switch (language) {
      case 'python':
        return [
          { label: 'def', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Define a function' },
          { label: 'if', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Conditional statement' },
          { label: 'else', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Else clause' },
          { label: 'elif', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Else if clause' },
          { label: 'for', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'For loop' },
          { label: 'while', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'While loop' },
          { label: 'return', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Return statement' },
          { label: 'import', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Import module' },
          { label: 'from', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Import from module' },
          { label: 'class', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Define a class' },
          { label: 'print', kind: monaco.languages.CompletionItemKind.Function, detail: 'Print to console', insertText: 'print($1)', documentation: 'Print objects to the console' },
          { label: 'len', kind: monaco.languages.CompletionItemKind.Function, detail: 'Get length', insertText: 'len($1)', documentation: 'Return the length of an object' },
          { label: 'range', kind: monaco.languages.CompletionItemKind.Function, detail: 'Range generator', insertText: 'range($1)', documentation: 'Generate a sequence of numbers' },
        ];
      case 'javascript':
        return [
          { label: 'function', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Define a function' },
          { label: 'if', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Conditional statement' },
          { label: 'else', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Else clause' },
          { label: 'for', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'For loop' },
          { label: 'while', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'While loop' },
          { label: 'return', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Return statement' },
          { label: 'const', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Constant variable' },
          { label: 'let', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Block-scoped variable' },
          { label: 'var', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Function-scoped variable' },
          { label: 'console.log', kind: monaco.languages.CompletionItemKind.Method, detail: 'Log to console', insertText: 'console.log($1)', documentation: 'Log objects to the browser console' },
        ];
      case 'java':
        return [
          { label: 'public', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Public access modifier' },
          { label: 'private', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Private access modifier' },
          { label: 'protected', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Protected access modifier' },
          { label: 'class', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Define a class' },
          { label: 'void', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Void return type' },
          { label: 'int', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Integer type' },
          { label: 'String', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'String type' },
          { label: 'boolean', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Boolean type' },
          { label: 'if', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Conditional statement' },
          { label: 'else', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Else clause' },
          { label: 'for', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'For loop' },
          { label: 'while', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'While loop' },
          { label: 'return', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Return statement' },
          { label: 'System.out.println', kind: monaco.languages.CompletionItemKind.Method, detail: 'Print to console', insertText: 'System.out.println($1)', documentation: 'Print objects to the console' },
        ];
      case 'cpp':
        return [
          { label: 'int', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Integer type' },
          { label: 'char', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Character type' },
          { label: 'bool', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Boolean type' },
          { label: 'float', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Float type' },
          { label: 'double', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Double type' },
          { label: 'void', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Void type' },
          { label: 'if', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Conditional statement' },
          { label: 'else', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Else clause' },
          { label: 'for', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'For loop' },
          { label: 'while', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'While loop' },
          { label: 'return', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Return statement' },
          { label: 'class', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Define a class' },
          { label: 'struct', kind: monaco.languages.CompletionItemKind.Keyword, detail: 'Define a struct' },
          { label: 'cout', kind: monaco.languages.CompletionItemKind.Variable, detail: 'Output stream', insertText: 'cout << $1', documentation: 'Output stream object' },
          { label: 'cin', kind: monaco.languages.CompletionItemKind.Variable, detail: 'Input stream', insertText: 'cin >> $1', documentation: 'Input stream object' },
        ];
      default:
        return [];
    }
  };

  // Component render
  return (
    <div className="relative min-h-screen text-white font-sans">
      <img src={mood} alt="bg" className="fixed top-0 left-0 w-full h-full object-cover z-0" />
      <div className="absolute top-0 left-0 w-full h-full bg-black/60 z-10"></div>

      <div className="relative z-20 flex flex-col lg:flex-row h-screen p-4 gap-6">
        {/* Sidebar */}
        <div className="lg:w-1/3 glass-panel p-4 overflow-y-auto flex flex-col">
          {/* Removed 'Back to Dashboard' button as requested */}

          <div className="mb-4">
              <label htmlFor="problem-selector" className="block mb-2 text-sm font-medium text-gray-300">Select a Problem</label>
              <div className="relative">
                <select
                  id="problem-selector"
                  value={problemId || ""}
                  onChange={(e) => handleProblemSelect(e.target.value)}
                  className="w-full p-3 pr-10 glass-panel-input backdrop-blur-xl bg-white/5 border border-white/10 rounded-xl appearance-none"
                >
                  <option value="" disabled>Choose a problem</option>
                  {allProblems.map((p) => (
                    <option key={p.id} value={p.id} className="bg-gray-900 text-white">
                      {p.title}
                    </option>
                  ))}
                </select>
                <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-3 text-white">
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path>
                  </svg>
                </div>
              </div>
          </div>

          <div className="flex-grow overflow-y-auto">
            {currentProblem ? (
              <>
                <div className="flex items-center justify-between mb-2">
                  <h3 className="text-xl font-semibold">{currentProblem.title}</h3>
                  {isProblemSolved && (
                    <span className="text-xs text-green-400 font-semibold flex items-center gap-1 bg-green-500/20 px-2 py-1 rounded-full">
                      <svg className="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
                        <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd"></path>
                      </svg>
                      Solved
                    </span>
                  )}
                </div>
                <p className="text-gray-300 text-sm mt-2 whitespace-pre-wrap">{currentProblem.description}</p>
                <h4 className="mt-4 font-semibold">Test Cases</h4>
                <div className="bg-gray-800/30 p-3 mt-2 rounded-lg border border-white/10">
                  {currentProblem.test_cases?.map((tc, i) => (
                    <div key={i} className="mb-2 text-sm">
                      <strong>Input:</strong> {JSON.stringify(tc.input)} <br />
                      <strong>Expected:</strong> {tc.output}
                    </div>
                  ))}
                </div>
              </>
            ) : (
               <p>{problemId ? "Loading problem..." : "Please select a problem from the dropdown."}</p>
            )}
          </div>
        </div>

        {/* Main */}
        <div className="lg:w-2/3 flex flex-col">
          <div className="glass-panel p-4 mb-4 flex gap-2 items-center">
            <div className="relative">
              <select
                value={language}
                onChange={(e) => setLanguage(e.target.value)}
                className="glass-panel-input pl-10 pr-10 appearance-none"
              >
                <option value="python" className="bg-gray-900 text-white">Python</option>
                <option value="javascript" className="bg-gray-900 text-white">JavaScript</option>
                <option value="cpp" className="bg-gray-900 text-white">C++</option>
                <option value="java" className="bg-gray-900 text-white">Java</option>
              </select>
              <div className="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3 text-white">
                {LanguageIcons[language]}
              </div>
              <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-3 text-white">
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path>
                </svg>
              </div>
            </div>
            <button
              onClick={runCode}
              disabled={isRunning}
              className={`px-4 py-2 rounded-lg font-bold ${isRunning ? "bg-gray-500" : "bg-green-600 hover:bg-green-700"}`}
            >
              {isRunning ? "Running..." : "Run Code"}
            </button>
            <button
              onClick={submitCode}
              className="px-4 py-2 rounded-lg font-bold bg-blue-600 hover:bg-blue-700"
            >
              Submit
            </button>
          </div>

          <div className="glass-panel flex-1 overflow-hidden mb-4">
            <MonacoEditor
              height="100%"
              language={language}
              theme="vs-dark"
              value={code}
              onChange={(val) => setCode(val || "")}
              onMount={handleEditorDidMount}
              options={{ 
                fontSize: 16, 
                minimap: { enabled: false }, 
                wordWrap: "on",
                suggestOnTriggerCharacters: true,
                quickSuggestions: true,
                snippetSuggestions: "inline"
              }}
            />
          </div>

          <div className="glass-panel p-4 h-30 overflow-y-auto font-mono text-sm whitespace-pre-wrap">
            {output}
          </div>
        </div>
      </div>

      <style>{`
        .glass-panel {
          backdrop-filter: blur(20px) saturate(180%);
          -webkit-backdrop-filter: blur(20px) saturate(180%);
          background-color: rgba(255, 255, 255, 0.1);
          border-radius: 20px;
          border: 1px solid rgba(255, 255, 255, 0.18);
          box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        .glass-panel-input {
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 8px;
            padding: 8px;
            color: white;
        }
        .glass-panel-input:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.5);
        }
      `}</style>
    </div>
  );

